/**
 * Internal Service Tool Implementation
 * Tool ID: {{tool_id}}
 * 
 * Generated by agent-builder. Customize as needed.
 * 
 * This template is for calling internal services within your infrastructure.
 * Uses service discovery or direct URLs based on configuration.
 */

import { agentError } from './errors.mjs';

/**
 * Execute {{tool_id}} internal service call
 * 
 * @param {object} input - Tool input matching input_schema
 * @param {object} context - Execution context
 * @param {object} context.manifest - Agent manifest
 * @param {string} context.contract_version - Contract version
 * @param {object} context.serviceClient - Service client (optional, uses fetch if not provided)
 * @param {object} context.logger - Logger instance (optional)
 * @returns {Promise<{ok: boolean, output?: object, error?: object}>}
 */
export async function {{tool_id}}(input, { manifest, contract_version, serviceClient, logger }) {
  const startTime = Date.now();
  const spec = manifest.tools?.tools?.find(t => t.id === '{{tool_id}}');
  
  // Get service URL from environment or service discovery
  const serviceUrl = process.env.{{tool_base_url_env}};
  
  if (!serviceUrl) {
    return {
      ok: false,
      error: agentError({
        contract_version,
        code: 'tool_config_error',
        message: '{{tool_id}}: Service URL not configured ({{tool_base_url_env}})',
        retryable: false
      })
    };
  }
  
  // Internal services may use different auth mechanisms
  const authToken = process.env.INTERNAL_SERVICE_TOKEN;
  const headers = {
    'Content-Type': 'application/json',
    'X-Request-ID': input._request_id || generateRequestId(),
    'X-Service-Name': 'agent-{{tool_id}}'
  };
  
  if (authToken) {
    headers['Authorization'] = `Bearer ${authToken}`;
  }
  
  // Add correlation ID if present
  if (input._correlation_id) {
    headers['X-Correlation-ID'] = input._correlation_id;
  }
  
  const timeoutMs = spec?.timeouts?.timeout_ms || {{timeout_ms}};
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    // Build request
    const requestBody = { ...input };
    delete requestBody._request_id;
    delete requestBody._correlation_id;
    
    // Use custom service client if provided, otherwise use fetch
    let response;
    
    if (serviceClient && typeof serviceClient.request === 'function') {
      response = await serviceClient.request({
        url: serviceUrl,
        method: 'POST',
        headers,
        body: requestBody,
        timeout: timeoutMs
      });
    } else {
      const fetchResponse = await fetch(serviceUrl, {
        method: 'POST',
        headers,
        body: JSON.stringify(requestBody),
        signal: controller.signal
      });
      
      clearTimeout(timeout);
      
      if (!fetchResponse.ok) {
        const errorBody = await fetchResponse.text().catch(() => '');
        
        // Map internal service errors
        const retryable = fetchResponse.status >= 500 || fetchResponse.status === 429;
        
        return {
          ok: false,
          error: agentError({
            contract_version,
            code: 'internal_service_error',
            message: `{{tool_id}}: Service returned ${fetchResponse.status}`,
            retryable,
            details: {
              status: fetchResponse.status,
              service: '{{tool_id}}',
              error: tryParseJson(errorBody)
            }
          })
        };
      }
      
      response = await fetchResponse.json();
    }
    
    // Handle service-level errors
    if (response.error || response.status === 'error') {
      return {
        ok: false,
        error: agentError({
          contract_version,
          code: response.error?.code || 'internal_service_error',
          message: response.error?.message || 'Service returned an error',
          retryable: response.error?.retryable || false,
          details: response.error?.details
        })
      };
    }
    
    // Audit logging
    if (spec?.audit?.required && logger) {
      logger.info({
        event: 'tool_executed',
        tool_id: '{{tool_id}}',
        duration_ms: Date.now() - startTime,
        service: serviceUrl,
        success: true
      });
    }
    
    // Return service response data
    return {
      ok: true,
      output: response.data || response.result || response
    };
    
  } catch (err) {
    clearTimeout(timeout);
    
    // Audit logging for failures
    if (spec?.audit?.required && logger) {
      logger.error({
        event: 'tool_failed',
        tool_id: '{{tool_id}}',
        duration_ms: Date.now() - startTime,
        service: serviceUrl,
        error: err.message
      });
    }
    
    const isTimeout = err.name === 'AbortError';
    const isNetwork = ['ECONNREFUSED', 'ENOTFOUND', 'ECONNRESET'].includes(err.code);
    
    return {
      ok: false,
      error: agentError({
        contract_version,
        code: isTimeout ? 'tool_timeout' : 'internal_service_error',
        message: `{{tool_id}}: ${err.message}`,
        retryable: isTimeout || isNetwork
      })
    };
  }
}

// Helpers

function generateRequestId() {
  return `req_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

function tryParseJson(str) {
  try {
    return JSON.parse(str);
  } catch {
    return str;
  }
}
