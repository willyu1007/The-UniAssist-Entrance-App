/**
 * Filesystem Tool Implementation
 * Tool ID: {{tool_id}}
 * 
 * Generated by agent-builder. Customize as needed.
 * 
 * WARNING: Filesystem operations can be destructive.
 * Ensure proper security validation is in place.
 */

import fs from 'node:fs';
import path from 'node:path';
import { agentError } from './errors.mjs';

// Allowed base directories (configure per environment)
const ALLOWED_PATHS = (process.env.AGENT_ALLOWED_PATHS || '').split(',').filter(Boolean);

/**
 * Validate that a path is within allowed directories
 */
function isPathAllowed(targetPath) {
  if (ALLOWED_PATHS.length === 0) {
    // If no allowed paths configured, deny all
    return false;
  }
  
  const resolved = path.resolve(targetPath);
  return ALLOWED_PATHS.some(allowed => {
    const allowedResolved = path.resolve(allowed);
    return resolved.startsWith(allowedResolved + path.sep) || resolved === allowedResolved;
  });
}

/**
 * Execute {{tool_id}} filesystem operation
 * 
 * @param {object} input - Tool input matching input_schema
 * @param {object} context - Execution context
 * @param {object} context.manifest - Agent manifest
 * @param {string} context.contract_version - Contract version
 * @param {object} context.logger - Logger instance (optional)
 * @returns {Promise<{ok: boolean, output?: object, error?: object}>}
 */
export async function {{tool_id}}(input, { manifest, contract_version, logger }) {
  const startTime = Date.now();
  const spec = manifest.tools?.tools?.find(t => t.id === '{{tool_id}}');
  
  // Validate input
  if (!input.path || typeof input.path !== 'string') {
    return {
      ok: false,
      error: agentError({
        contract_version,
        code: 'invalid_input',
        message: '{{tool_id}}: Path is required',
        retryable: false
      })
    };
  }
  
  // Security: Validate path is allowed
  if (!isPathAllowed(input.path)) {
    if (logger) {
      logger.warn({
        event: 'security_blocked',
        tool_id: '{{tool_id}}',
        path: input.path,
        reason: 'path_not_allowed'
      });
    }
    
    return {
      ok: false,
      error: agentError({
        contract_version,
        code: 'security_violation',
        message: '{{tool_id}}: Access to this path is not allowed',
        retryable: false
      })
    };
  }
  
  // Security: Prevent path traversal
  const resolvedPath = path.resolve(input.path);
  if (resolvedPath.includes('..')) {
    return {
      ok: false,
      error: agentError({
        contract_version,
        code: 'security_violation',
        message: '{{tool_id}}: Path traversal detected',
        retryable: false
      })
    };
  }
  
  const operation = input.operation || 'read';
  
  try {
    let result;
    
    switch (operation) {
      case 'read':
        result = await readFile(resolvedPath, input.options);
        break;
        
      case 'write':
        result = await writeFile(resolvedPath, input.content, input.options);
        break;
        
      case 'list':
        result = await listDirectory(resolvedPath, input.options);
        break;
        
      case 'exists':
        result = await checkExists(resolvedPath);
        break;
        
      case 'stat':
        result = await getStats(resolvedPath);
        break;
        
      default:
        return {
          ok: false,
          error: agentError({
            contract_version,
            code: 'invalid_input',
            message: `{{tool_id}}: Unknown operation '${operation}'`,
            retryable: false
          })
        };
    }
    
    // Audit logging
    if (spec?.audit?.required && logger) {
      logger.info({
        event: 'tool_executed',
        tool_id: '{{tool_id}}',
        duration_ms: Date.now() - startTime,
        operation,
        path: resolvedPath,
        success: true
      });
    }
    
    return { ok: true, output: result };
    
  } catch (err) {
    // Audit logging for failures
    if (spec?.audit?.required && logger) {
      logger.error({
        event: 'tool_failed',
        tool_id: '{{tool_id}}',
        duration_ms: Date.now() - startTime,
        operation,
        path: resolvedPath,
        error: err.message
      });
    }
    
    const retryable = err.code === 'EBUSY' || err.code === 'EAGAIN';
    
    return {
      ok: false,
      error: agentError({
        contract_version,
        code: 'filesystem_error',
        message: `{{tool_id}}: ${err.message}`,
        retryable,
        details: {
          code: err.code,
          syscall: err.syscall
        }
      })
    };
  }
}

// Helper functions

async function readFile(filePath, options = {}) {
  const encoding = options.encoding || 'utf8';
  const content = await fs.promises.readFile(filePath, encoding);
  return {
    path: filePath,
    content,
    size: Buffer.byteLength(content, encoding)
  };
}

async function writeFile(filePath, content, options = {}) {
  const encoding = options.encoding || 'utf8';
  
  // Create directory if needed
  const dir = path.dirname(filePath);
  await fs.promises.mkdir(dir, { recursive: true });
  
  // Write file
  await fs.promises.writeFile(filePath, content, encoding);
  
  return {
    path: filePath,
    written: true,
    size: Buffer.byteLength(content, encoding)
  };
}

async function listDirectory(dirPath, options = {}) {
  const entries = await fs.promises.readdir(dirPath, { withFileTypes: true });
  
  const items = entries.map(entry => ({
    name: entry.name,
    type: entry.isDirectory() ? 'directory' : entry.isFile() ? 'file' : 'other',
    path: path.join(dirPath, entry.name)
  }));
  
  if (options.filesOnly) {
    return { path: dirPath, items: items.filter(i => i.type === 'file') };
  }
  
  if (options.directoriesOnly) {
    return { path: dirPath, items: items.filter(i => i.type === 'directory') };
  }
  
  return { path: dirPath, items };
}

async function checkExists(targetPath) {
  try {
    await fs.promises.access(targetPath);
    return { path: targetPath, exists: true };
  } catch {
    return { path: targetPath, exists: false };
  }
}

async function getStats(targetPath) {
  const stats = await fs.promises.stat(targetPath);
  return {
    path: targetPath,
    size: stats.size,
    isFile: stats.isFile(),
    isDirectory: stats.isDirectory(),
    created: stats.birthtime.toISOString(),
    modified: stats.mtime.toISOString(),
    accessed: stats.atime.toISOString()
  };
}
