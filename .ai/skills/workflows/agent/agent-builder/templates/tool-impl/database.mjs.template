/**
 * Database Tool Implementation
 * Tool ID: {{tool_id}}
 * 
 * Generated by agent-builder. Customize as needed.
 * 
 * Note: This template assumes a generic database client interface.
 * Replace with your actual database driver (pg, mysql2, etc.)
 */

import { agentError } from './errors.mjs';

/**
 * Execute {{tool_id}} database operation
 * 
 * @param {object} input - Tool input matching input_schema
 * @param {object} context - Execution context
 * @param {object} context.manifest - Agent manifest
 * @param {string} context.contract_version - Contract version
 * @param {object} context.db - Database client instance
 * @param {object} context.logger - Logger instance (optional)
 * @returns {Promise<{ok: boolean, output?: object, error?: object}>}
 */
export async function {{tool_id}}(input, { manifest, contract_version, db, logger }) {
  const startTime = Date.now();
  const spec = manifest.tools?.tools?.find(t => t.id === '{{tool_id}}');
  
  // Validate database client
  if (!db) {
    return {
      ok: false,
      error: agentError({
        contract_version,
        code: 'tool_config_error',
        message: '{{tool_id}}: Database client not provided',
        retryable: false
      })
    };
  }
  
  // Validate input
  if (!input.query || typeof input.query !== 'string') {
    return {
      ok: false,
      error: agentError({
        contract_version,
        code: 'invalid_input',
        message: '{{tool_id}}: Query string is required',
        retryable: false
      })
    };
  }
  
  // Security: Basic query validation
  const dangerousPatterns = [
    /;\s*DROP\s+/i,
    /;\s*DELETE\s+/i,
    /;\s*TRUNCATE\s+/i,
    /;\s*ALTER\s+/i,
    /--/,
    /\/\*/
  ];
  
  for (const pattern of dangerousPatterns) {
    if (pattern.test(input.query)) {
      return {
        ok: false,
        error: agentError({
          contract_version,
          code: 'security_violation',
          message: '{{tool_id}}: Query contains potentially dangerous pattern',
          retryable: false
        })
      };
    }
  }
  
  const timeoutMs = spec?.timeouts?.timeout_ms || {{timeout_ms}};
  
  try {
    // Execute query with timeout
    const result = await Promise.race([
      db.query(input.query, input.params || []),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Query timeout')), timeoutMs)
      )
    ]);
    
    // Audit logging
    if (spec?.audit?.required && logger) {
      logger.info({
        event: 'tool_executed',
        tool_id: '{{tool_id}}',
        duration_ms: Date.now() - startTime,
        success: true,
        row_count: result.rowCount || result.rows?.length || 0
      });
    }
    
    return {
      ok: true,
      output: {
        rows: result.rows || [],
        rowCount: result.rowCount || result.rows?.length || 0,
        fields: result.fields?.map(f => f.name) || []
      }
    };
    
  } catch (err) {
    // Audit logging for failures
    if (spec?.audit?.required && logger) {
      logger.error({
        event: 'tool_failed',
        tool_id: '{{tool_id}}',
        duration_ms: Date.now() - startTime,
        error: err.message
      });
    }
    
    // Determine if error is retryable
    const retryable = [
      'ECONNRESET',
      'ECONNREFUSED',
      'ETIMEDOUT',
      'Connection terminated'
    ].some(code => err.message.includes(code) || err.code === code);
    
    return {
      ok: false,
      error: agentError({
        contract_version,
        code: err.message.includes('timeout') ? 'tool_timeout' : 'database_error',
        message: `{{tool_id}}: ${err.message}`,
        retryable,
        details: {
          code: err.code,
          constraint: err.constraint,
          table: err.table
        }
      })
    };
  }
}
