import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { runAgent } from '../../core/run.mjs';
import { nowIso } from '../../core/util.mjs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function listJsonFiles(dir) {
  if (!fs.existsSync(dir)) return [];
  return fs.readdirSync(dir)
    .filter(f => f.endsWith('.json'))
    .map(f => path.join(dir, f));
}

function moveFile(src, dstDir) {
  ensureDir(dstDir);
  const dst = path.join(dstDir, path.basename(src));
  fs.renameSync(src, dst);
  return dst;
}

// Simple semaphore for concurrency control
class Semaphore {
  constructor(max) {
    this.max = max;
    this.current = 0;
    this.queue = [];
  }

  async acquire() {
    if (this.current < this.max) {
      this.current++;
      return;
    }
    await new Promise(resolve => this.queue.push(resolve));
    this.current++;
  }

  release() {
    this.current--;
    if (this.queue.length > 0) {
      const next = this.queue.shift();
      next();
    }
  }

  async run(fn) {
    await this.acquire();
    try {
      return await fn();
    } finally {
      this.release();
    }
  }
}

async function processOne(filePath, outDir, doneDir, failedDir) {
  let req;
  try {
    req = JSON.parse(fs.readFileSync(filePath, 'utf8'));
  } catch (e) {
    // invalid JSON â†’ failed
    const errOut = { type: 'error', timestamp: nowIso(), data: { code: 'invalid_json', message: String(e && e.message ? e.message : e) } };
    const outFile = path.join(outDir, path.basename(filePath).replace(/\.json$/, '.error.json'));
    ensureDir(outDir);
    fs.writeFileSync(outFile, JSON.stringify(errOut, null, 2));
    moveFile(filePath, failedDir);
    return;
  }

  try {
    const result = await runAgent(req, { responseMode: 'async' });
    ensureDir(outDir);
    if (!result.ok) {
      const outFile = path.join(outDir, `${req.request_id || path.basename(filePath)}.error.json`);
      fs.writeFileSync(outFile, JSON.stringify(result.error, null, 2));
      moveFile(filePath, failedDir);
      return;
    }
    const outFile = path.join(outDir, `${req.request_id || path.basename(filePath)}.out.json`);
    fs.writeFileSync(outFile, JSON.stringify(result.response, null, 2));
    moveFile(filePath, doneDir);
  } catch (e) {
    const outFile = path.join(outDir, `${req.request_id || path.basename(filePath)}.error.json`);
    ensureDir(outDir);
    fs.writeFileSync(outFile, JSON.stringify({ error: String(e && e.message ? e.message : e) }, null, 2));
    moveFile(filePath, failedDir);
  }
}

export async function run() {
  const inDir = process.env.AGENT_WORKER_INPUT_DIR || './var/worker/in';
  const outDir = process.env.AGENT_WORKER_OUTPUT_DIR || './var/worker/out';

  ensureDir(inDir);
  ensureDir(outDir);

  const doneDir = path.join(inDir, '.done');
  const failedDir = path.join(inDir, '.failed');
  ensureDir(doneDir);
  ensureDir(failedDir);

  // Concurrency control: default 4, configurable via env
  const maxConcurrency = Number(process.env.AGENT_WORKER_MAX_CONCURRENCY || 4);
  const semaphore = new Semaphore(maxConcurrency);

  console.log(`[worker] watching inDir=${inDir} outDir=${outDir} maxConcurrency=${maxConcurrency}`);

  const pollMs = Number(process.env.AGENT_WORKER_POLL_MS || 1000);

  // Track files currently being processed to avoid duplicate processing
  const processingFiles = new Set();

  // Polling loop with concurrent processing
  setInterval(async () => {
    try {
      const files = listJsonFiles(inDir)
        .filter(p => !p.includes(path.sep + '.done' + path.sep))
        .filter(p => !p.includes(path.sep + '.failed' + path.sep))
        .filter(p => !processingFiles.has(p));

      for (const f of files) {
        processingFiles.add(f);
        // Process concurrently with semaphore limit
        semaphore.run(async () => {
          try {
            await processOne(f, outDir, doneDir, failedDir);
          } finally {
            processingFiles.delete(f);
          }
        }).catch(() => {
          processingFiles.delete(f);
        });
      }
    } catch (e) {
      // Ignore polling errors
    }
  }, pollMs);
}

export { Semaphore };

// ESM entry point detection
const isMain = process.argv[1] && import.meta.url.endsWith(process.argv[1].replace(/\\/g, '/'));
if (isMain) run();
